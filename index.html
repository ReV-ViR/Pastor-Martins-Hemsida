<!DOCTYPE html>
<html lang="sv">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Pastor Martins undervisning</title>
  <link rel="stylesheet" href="styles.css" />
</head>

<body>
  <header>
    <h1>Pastor Martins undervisning</h1>
    <p>Ljudserier</p>
  </header>

  <main>
    <div class="top-note">
      <div><strong>Tips:</strong> När du startar ett avsnitt pausas alla andra automatiskt. Sidan kommer ihåg senast spelade avsnitt.</div>
    </div>

    <div class="tab-container" id="tabList" role="tablist" aria-label="Undervisningsserier"></div>
    <div id="tabPanels"></div>
  </main>

  <footer>
    <p>Kontakt: <a href="mailto:martin.harsmar@live.se">martin.harsmar@live.se</a></p>
    <p>Karlskoga-Degerfors Baptistförsamling</p>
    <p>Telefon: 073-613 0782</p>
  </footer>

  <!-- Mini player (bottom) -->
  <div class="mini-player" id="miniPlayer" hidden>
    <div class="mini-wrap">
      <div class="mini-meta">
        <p class="mini-title" id="miniTitle">—</p>
        <p class="mini-sub" id="miniSub">—</p>
      </div>

      <audio class="mini-audio" id="miniAudio" controls></audio>

      <div class="mini-actions">
        <button class="btn" id="miniGoTo">Visa</button>
        <button class="btn primary" id="miniClear">Rensa</button>
      </div>
    </div>
  </div>

  <script>
    /***********************
     * 0) R2 BASE (bucket root)
     ***********************/
    const R2_BASE = "https://pub-bac38cc7629d4743b23aabcdaaebae74.r2.dev";

    // Build: https://pub-...r2.dev/<folder>/<file>
    function buildR2Url(folderSlug, fileName) {
      const segments = [folderSlug, fileName].map(s => encodeURIComponent(s));
      return `${R2_BASE}/${segments.join("/")}`;
    }

    /***********************
     * 1) MANIFEST – matchar exakt din R2
     ***********************/
    const SERIES = [
      {
        id: "blodsforbundet",
        tabTitle: "Blodsförbundet",
        heading: "Blodsförbundet",
        introHtml: "<p><strong>Tack Ola Gustavsson för inspirationen – mycket av materialet är hämtat från dina undervisningar.</strong></p>",
        folder: "blodsforbundet",
        items: Array.from({ length: 15 }, (_, i) => {
          const n = i + 1;
          return { title: `Blodsförbundet Del ${n}`, file: `del-${String(n).padStart(2, "0")}.m4a` };
        })
      },
      {
        id: "bon",
        tabTitle: "Bön",
        heading: "Bön",
        folder: "bon",
        items: [1, 2, 3].map(n => ({ title: `Bön Del ${n}`, file: `del-${String(n).padStart(2, "0")}.m4a` }))
      },
      {
        id: "den-helige-ande",
        tabTitle: "Den Helige Ande",
        heading: "Den Helige Ande",
        folder: "den-helige-ande",
        items: [1, 2].map(n => ({ title: `Den Helige Ande – Del ${n}`, file: `del-${String(n).padStart(2, "0")}.m4a` }))
      },
      {
        id: "forsoningslara",
        tabTitle: "Försoningslära",
        heading: "Försoningslära",
        folder: "forsoningslara",
        items: [1, 2, 3].map(n => ({ title: `Försoningslära – Del ${n}`, file: `del-${String(n).padStart(2, "0")}.m4a` }))
      },
      {
        id: "kyrkohistoria",
        tabTitle: "Kyrkohistoria",
        heading: "Kyrkohistoria",
        folder: "kyrkohistoria",
        items: [
          ...Array.from({ length: 19 }, (_, i) => {
            const n = i + 1;
            return { title: `Kyrkohistoria Del ${n}`, file: `del-${String(n).padStart(2, "0")}.m4a` };
          }),
          { title: "Pingstväckelsens historia Del 1", file: "pingstvackelsens-historia-del-01.mp3" },
          { title: "Pingstväckelsens historia Del 2", file: "pingstvackelsens-historia-del-02.mp3" }
        ]
      },
      {
        id: "sex-och-relationer",
        tabTitle: "Sex och relationer",
        heading: "Sex och relationer",
        folder: "sex-och-relationer",
        items: [1, 2].map(n => ({ title: `Sex och relationer Del ${n}`, file: `del-${String(n).padStart(2, "0")}.m4a` }))
      },
      {
        id: "anglar-och-demoner",
        tabTitle: "Änglar och demoner",
        heading: "Änglar och demoner",
        folder: "anglar-och-demoner",
        items: [1, 2, 3].map(n => ({ title: `Änglar och demoner – Del ${n}`, file: `del-${String(n).padStart(2, "0")}.m4a` }))
      }
    ];

    /***********************
     * 2) Render tabs + panels
     ***********************/
    const tabList = document.getElementById("tabList");
    const tabPanels = document.getElementById("tabPanels");

    function el(tag, attrs = {}, children = []) {
      const node = document.createElement(tag);
      for (const [k, v] of Object.entries(attrs)) {
        if (k === "class") node.className = v;
        else if (k === "html") node.innerHTML = v;
        else node.setAttribute(k, v);
      }
      for (const c of children) node.appendChild(c);
      return node;
    }

    function render() {
      tabList.innerHTML = "";
      tabPanels.innerHTML = "";

      SERIES.forEach((s, idx) => {
        // TAB
        const tab = el("div", {
          class: "tab" + (idx === 0 ? " active" : ""),
          role: "tab",
          "aria-selected": idx === 0 ? "true" : "false",
          "data-tab": s.id
        });
        tab.textContent = s.tabTitle;
        tabList.appendChild(tab);

        // PANEL
        const panel = el("div", {
          class: "tab-content" + (idx === 0 ? " active" : ""),
          id: s.id,
          role: "tabpanel"
        });

        panel.appendChild(el("h2", {}, [document.createTextNode(s.heading)]));
        if (s.introHtml) panel.appendChild(el("div", { html: s.introHtml }));

        const ul = el("ul");
        s.items.forEach(item => {
          const li = el("li");

          const head = el("div", { class: "item-head" });
          const h3 = el("h3", { class: "item-title" }, [document.createTextNode(item.title)]);
          const chip = el("span", { class: "chip now-playing-chip", hidden: "true" }, [document.createTextNode("Spelas nu")]);

          head.appendChild(h3);
          head.appendChild(chip);

          const audio = el("audio", {
            controls: "true",
            preload: "none",
            "data-series-id": s.id,
            "data-series-title": s.tabTitle,
            "data-folder": s.folder,
            "data-file": item.file,
            "data-title": item.title
          });

          li.appendChild(head);
          li.appendChild(audio);
          ul.appendChild(li);
        });

        panel.appendChild(ul);
        tabPanels.appendChild(panel);
      });
    }

    render();

    /***********************
     * 3) Tabs behavior
     ***********************/
    const tabs = () => Array.from(document.querySelectorAll(".tab"));
    const panels = () => Array.from(document.querySelectorAll(".tab-content"));

    function activateTab(tabId) {
      tabs().forEach(t => {
        const isActive = t.dataset.tab === tabId;
        t.classList.toggle("active", isActive);
        t.setAttribute("aria-selected", isActive ? "true" : "false");
      });
      panels().forEach(p => p.classList.toggle("active", p.id === tabId));
      setTimeout(scrollToNowPlaying, 50);
    }

    tabs().forEach(t => t.addEventListener("click", () => activateTab(t.dataset.tab)));

    /***********************
     * 4) Wire audio sources from manifest
     ***********************/
    const audioEls = Array.from(document.querySelectorAll('audio[data-folder][data-file]'));
    audioEls.forEach(a => {
      const folder = a.getAttribute("data-folder");
      const file = a.getAttribute("data-file");
      a.src = buildR2Url(folder, file);
      a.preload = "none";
    });

    /***********************
     * 5) Autopause + Now playing chip + scroll
     ***********************/
    let currentAudio = null;

    function clearNowPlayingChips() {
      document.querySelectorAll(".now-playing-chip").forEach(chip => chip.hidden = true);
      document.querySelectorAll("li").forEach(li => li.style.outline = "");
    }

    function markNowPlaying(audioEl) {
      clearNowPlayingChips();
      const li = audioEl.closest("li");
      if (!li) return;
      li.style.outline = "3px solid rgba(0,91,150,.20)";
      const chip = li.querySelector(".now-playing-chip");
      if (chip) chip.hidden = false;
    }

    function scrollToNowPlaying() {
      const playing = currentAudio && !currentAudio.paused ? currentAudio : null;
      if (!playing) return;
      const li = playing.closest("li");
      if (!li) return;
      li.scrollIntoView({ behavior: "smooth", block: "center" });
    }

    function activateTabForAudio(audioEl) {
      const panel = audioEl.closest(".tab-content");
      if (!panel) return;
      activateTab(panel.id);
    }

    /***********************
     * 6) Remember last playback (localStorage)
     ***********************/
    const STORAGE_KEY = "pm_last_playback_v3";

    function saveLastPlaybackFromAudio(audioEl, extra = {}) {
      const payload = {
        src: audioEl.currentSrc || audioEl.src,
        series: audioEl.getAttribute("data-series-title") || "Okänd serie",
        title: audioEl.getAttribute("data-title") || "Okänt avsnitt",
        time: isFinite(audioEl.currentTime) ? audioEl.currentTime : 0,
        updatedAt: Date.now(),
        ...extra
      };
      try { localStorage.setItem(STORAGE_KEY, JSON.stringify(payload)); } catch (e) {}
    }

    function loadLastPlayback() {
      try {
        const raw = localStorage.getItem(STORAGE_KEY);
        if (!raw) return null;
        return JSON.parse(raw);
      } catch (e) {
        return null;
      }
    }

    audioEls.forEach(a => {
      a.addEventListener("play", () => {
        // pausa alla andra
        audioEls.forEach(other => {
          if (other !== a && !other.paused) other.pause();
        });

        currentAudio = a;
        markNowPlaying(a);
        saveLastPlaybackFromAudio(a);
        updateMiniPlayerFromAudio(a);

        activateTabForAudio(a);
        setTimeout(scrollToNowPlaying, 80);
      });

      a.addEventListener("pause", () => {
        if (currentAudio === a) clearNowPlayingChips();
      });

      a.addEventListener("timeupdate", () => {
        if (currentAudio === a && !a.paused) {
          saveLastPlaybackFromAudio(a);
          updateMiniPlayerFromAudio(a);
        }
      });

      a.addEventListener("ended", () => {
        if (currentAudio === a) {
          clearNowPlayingChips();
          saveLastPlaybackFromAudio(a, { ended: true });
          updateMiniPlayerFromAudio(a);
        }
      });

      a.addEventListener("error", () => {
        console.warn("Audio error:", a.src);
      });
    });

    /***********************
     * 7) Mini player
     ***********************/
    const miniPlayer = document.getElementById("miniPlayer");
    const miniAudio = document.getElementById("miniAudio");
    const miniTitle = document.getElementById("miniTitle");
    const miniSub = document.getElementById("miniSub");
    const miniGoTo = document.getElementById("miniGoTo");
    const miniClear = document.getElementById("miniClear");

    function showMiniPlayer(data) {
      if (!data || !data.src) return;
      miniPlayer.hidden = false;
      miniTitle.textContent = data.title || "—";
      miniSub.textContent = `Kategori: ${data.series || "—"}`;

      if (miniAudio.src !== data.src) {
        miniAudio.src = data.src;
        miniAudio.currentTime = 0;
      }
      if (isFinite(data.time) && data.time > 0) {
        try { miniAudio.currentTime = data.time; } catch (e) {}
      }
    }

    function updateMiniPlayerFromAudio(audioEl) {
      showMiniPlayer({
        src: audioEl.currentSrc || audioEl.src,
        series: audioEl.getAttribute("data-series-title") || "Okänd serie",
        title: audioEl.getAttribute("data-title") || "Okänt avsnitt",
        time: audioEl.currentTime || 0
      });
    }

    miniAudio.addEventListener("play", () => {
      // pausa alla andra
      audioEls.forEach(other => { if (!other.paused) other.pause(); });

      // matcha miniplayer src till list-audio om möjligt
      const match = audioEls.find(a => (a.currentSrc || a.src) === miniAudio.currentSrc);
      if (match) {
        currentAudio = match;
        markNowPlaying(match);
        activateTabForAudio(match);
        setTimeout(scrollToNowPlaying, 80);
      }
    });

    miniAudio.addEventListener("timeupdate", () => {
      const existing = loadLastPlayback();
      if (!existing) return;
      const payload = { ...existing, time: miniAudio.currentTime || 0, updatedAt: Date.now() };
      try { localStorage.setItem(STORAGE_KEY, JSON.stringify(payload)); } catch (e) {}
    });

    miniGoTo.addEventListener("click", () => {
      const match = audioEls.find(a => (a.currentSrc || a.src) === miniAudio.currentSrc);
      if (match) {
        activateTabForAudio(match);
        currentAudio = match;
        markNowPlaying(match);
        setTimeout(scrollToNowPlaying, 80);
      } else {
        window.scrollTo({ top: 0, behavior: "smooth" });
      }
    });

    miniClear.addEventListener("click", () => {
      try { localStorage.removeItem(STORAGE_KEY); } catch (e) {}
      miniAudio.pause();
      miniAudio.removeAttribute("src");
      miniAudio.load();
      miniPlayer.hidden = true;
      clearNowPlayingChips();
      currentAudio = null;
    });

    window.addEventListener("load", () => {
      const last = loadLastPlayback();
      if (last && last.src) {
        showMiniPlayer(last);
        miniAudio.preload = "metadata";
      }
    });
  </script>
</body>
</html>
